#![feature(once_cell_try)]
#![feature(trusted_len)]
//! Vortex crate containing core logic for encoding and memory representation of [arrays](ArrayData).
//!
//! At the heart of Vortex are [arrays](ArrayData) and [encodings](crate::encoding::ArrayEncoding).
//! Arrays are typed views of memory buffers that hold [scalars](vortex_scalar::Scalar). These
//! buffers can be held in a number of physical encodings to perform lightweight compression that
//! exploits the particular data distribution of the array's values.
//!
//! Every data type recognized by Vortex also has a canonical physical encoding format, which
//! arrays can be [canonicalized](Canonical) into for ease of access in compute functions.
//!

pub use canonical::*;
pub use context::*;
pub use data::*;
pub use macros::*;
pub use metadata::*;
pub use paste;
use stats::Statistics;
pub use typed::*;
use vortex_buffer::Buffer;
use vortex_dtype::DType;
use vortex_error::{VortexExpect, VortexResult};

use crate::array::visitor::{AcceptArrayVisitor, ArrayVisitor};
use crate::compute::ArrayCompute;
use crate::encoding::ArrayEncodingRef;
use crate::stats::{ArrayStatistics, ArrayStatisticsCompute};
use crate::validity::ArrayValidity;
use crate::variants::ArrayVariants;

pub mod accessor;
pub mod aliases;
pub mod array;
pub mod arrow;
mod canonical;
pub mod compress;
pub mod compute;
mod context;
mod data;
pub mod elementwise;
pub mod encoding;
pub mod iter;
mod macros;
mod metadata;
pub mod stats;
pub mod stream;
pub mod tree;
mod typed;
pub mod validity;
pub mod variants;

pub mod flatbuffers {
    //! Re-exported autogenerated code from the core Vortex flatbuffer definitions.
    pub use vortex_flatbuffers::array::*;
}

/// A depth-first pre-order iterator over a ArrayData.
pub struct ArrayChildrenIterator {
    stack: Vec<ArrayData>,
}

impl ArrayChildrenIterator {
    pub fn new(array: ArrayData) -> Self {
        Self { stack: vec![array] }
    }
}

impl Iterator for ArrayChildrenIterator {
    type Item = ArrayData;

    fn next(&mut self) -> Option<Self::Item> {
        let next = self.stack.pop()?;
        for child in next.children().into_iter().rev() {
            self.stack.push(child);
        }
        Some(next)
    }
}

pub trait ToArrayData {
    fn to_array(&self) -> ArrayData;
}

/// Consume `self` and turn it into an [`ArrayData`] infallibly.
///
/// Implementation of this array should never fail.
pub trait IntoArrayData {
    fn into_array(self) -> ArrayData;
}

/// Collects together the behavior of an array.
pub trait ArrayTrait:
    ArrayEncodingRef
    + ArrayCompute
    + ArrayDType
    + ArrayLen
    + ArrayVariants
    + IntoCanonical
    + ArrayValidity
    + AcceptArrayVisitor
    + ArrayStatistics
    + ArrayStatisticsCompute
{
    /// Total size of the array in bytes, including all children and buffers.
    fn nbytes(&self) -> usize {
        let mut visitor = NBytesVisitor(0);
        self.accept(&mut visitor)
            .vortex_expect("Failed to get nbytes from Array");
        visitor.0
    }
}

pub trait ArrayDType {
    // TODO(ngates): move into ArrayTrait?
    fn dtype(&self) -> &DType;
}

impl<T: AsRef<ArrayData>> ArrayDType for T {
    fn dtype(&self) -> &DType {
        match &self.as_ref().0 {
            InnerArrayData::Owned(array_data) => array_data.dtype(),
            InnerArrayData::Viewed(array_view) => array_view.dtype(),
        }
    }
}

pub trait ArrayLen {
    fn len(&self) -> usize;

    fn is_empty(&self) -> bool;
}

impl<T: AsRef<ArrayData>> ArrayLen for T {
    fn len(&self) -> usize {
        match &self.as_ref().0 {
            InnerArrayData::Owned(d) => d.len(),
            InnerArrayData::Viewed(v) => v.len(),
        }
    }

    fn is_empty(&self) -> bool {
        match &self.as_ref().0 {
            InnerArrayData::Owned(d) => d.is_empty(),
            InnerArrayData::Viewed(v) => v.is_empty(),
        }
    }
}

struct NBytesVisitor(usize);

impl ArrayVisitor for NBytesVisitor {
    fn visit_child(&mut self, _name: &str, array: &ArrayData) -> VortexResult<()> {
        self.0 += array.with_dyn(|a| a.nbytes());
        Ok(())
    }

    fn visit_buffer(&mut self, buffer: &Buffer) -> VortexResult<()> {
        self.0 += buffer.len();
        Ok(())
    }
}

impl<T: AsRef<ArrayData>> ArrayStatistics for T {
    fn statistics(&self) -> &(dyn Statistics + '_) {
        match &self.as_ref().0 {
            InnerArrayData::Owned(d) => d.statistics(),
            InnerArrayData::Viewed(v) => v.statistics(),
        }
    }

    fn inherit_statistics(&self, parent: &dyn Statistics) {
        let stats = self.statistics();
        for (stat, scalar) in parent.to_set() {
            stats.set(stat, scalar);
        }
    }
}
